import {
  readdirSync,
  statSync,
  readFileSync,
  existsSync,
  mkdirSync,
  writeFileSync,
} from "fs";
import { join, dirname } from "path";
import { fileURLToPath } from "url";
import { format } from "prettier";

const __dirname = dirname(fileURLToPath(import.meta.url));

const generatedContractComment = `
/**
 * This file is autogenerated by W3Final Scaffold.
 * You should not edit it manually or your changes might be overwritten.
 */`;

function getDirectories(path) {
  if (!existsSync(path)) {
    return [];
  }

  return readdirSync(path).filter(function (file) {
    return statSync(join(path, file)).isDirectory();
  });
}

function getFiles(path) {
  return readdirSync(path).filter(function (file) {
    return statSync(join(path, file)).isFile();
  });
}

function parseTransactionAndReceiptRun(filePath) {
  try {
    const content = readFileSync(filePath, "utf8");
    const broadcastData = JSON.parse(content);
    return {
      transactions: broadcastData.transactions || [],
      receipts: broadcastData.receipts || [],
    };
  } catch (error) {
    console.warn(`Warning: Could not parse ${filePath}:`, error.message);
    return [];
  }
}

function getDeploymentHistory(broadcastPath) {
  const files = getFiles(broadcastPath);
  const deploymentHistory = new Map();

  // Sort files to process them in chronological order
  const runFiles = files
    .filter(
      (file) =>
        file.startsWith("run-") &&
        file.endsWith(".json") &&
        !file.includes("run-latest")
    )
    .sort((a, b) => {
      // Extract run numbers and compare them
      const runA = parseInt(a.match(/run-(\d+)/)?.[1] || "0");
      const runB = parseInt(b.match(/run-(\d+)/)?.[1] || "0");
      return runA - runB;
    });

  for (const file of runFiles) {
    const { transactions, receipts } = parseTransactionAndReceiptRun(
      join(broadcastPath, file)
    );

    for (const tx of transactions) {
      if (tx.transactionType === "CREATE" || tx.transactionType === "CREATE2") {
        // Store or update contract deployment info
        deploymentHistory.set(tx.contractAddress, {
          contractName: tx.contractName,
          address: tx.contractAddress,
          deploymentFile: file,
          transaction: tx,
          receipt: receipts.find((r) => r.transactionHash === tx.hash),
        });
      }
    }
  }

  return Array.from(deploymentHistory.values());
}

function getArtifactOfContract(contractName) {
  // Handle renamed contracts: AntToken -> ZLTToken
  let actualContractName = contractName;
  if (contractName === "AntToken") {
    actualContractName = "ZLTToken";
  }

  const current_path_to_artifacts = join(
    __dirname,
    "..",
    `out/${actualContractName}.sol`
  );

  if (!existsSync(current_path_to_artifacts)) return null;

  const artifactJson = JSON.parse(
    readFileSync(`${current_path_to_artifacts}/${actualContractName}.json`)
  );

  return artifactJson;
}

function getInheritedFromContracts(artifact) {
  let inheritedFromContracts = [];
  if (artifact?.ast) {
    for (const astNode of artifact.ast.nodes) {
      if (astNode.nodeType == "ContractDefinition") {
        if (astNode.baseContracts.length > 0) {
          inheritedFromContracts = astNode.baseContracts.map(
            ({ baseName }) => baseName.name
          );
        }
      }
    }
  }
  return inheritedFromContracts;
}

function getInheritedFunctions(mainArtifact) {
  const inheritedFromContracts = getInheritedFromContracts(mainArtifact);
  const inheritedFunctions = {};
  for (const inheritanceContractName of inheritedFromContracts) {
    const artifact = getArtifactOfContract(inheritanceContractName);
    if (artifact) {
      const {
        abi,
        ast: { absolutePath },
      } = artifact;
      for (const abiEntry of abi) {
        if (abiEntry.type == "function") {
          inheritedFunctions[abiEntry.name] = absolutePath;
        }
      }
    }
  }
  return inheritedFunctions;
}

function processAllDeployments(broadcastPath) {
  const scriptFolders = getDirectories(broadcastPath);
  const allDeployments = new Map();
  const proxyDeployments = new Map(); // Track ERC1967Proxy deployments

  scriptFolders.forEach((scriptFolder) => {
    const scriptPath = join(broadcastPath, scriptFolder);
    const chainFolders = getDirectories(scriptPath);

    chainFolders.forEach((chainId) => {
      const chainPath = join(scriptPath, chainId);
      const deploymentHistory = getDeploymentHistory(chainPath);

      deploymentHistory.forEach((deployment) => {
        const timestamp = parseInt(
          deployment.deploymentFile.match(/run-(\d+)/)?.[1] || "0"
        );
        const key = `${chainId}-${deployment.contractName}`;

        // Track ERC1967Proxy deployments separately
        if (deployment.contractName === "ERC1967Proxy") {
          const proxyKey = `${chainId}-${deployment.address}`;
          if (
            !proxyDeployments.has(proxyKey) ||
            timestamp > proxyDeployments.get(proxyKey).timestamp
          ) {
            proxyDeployments.set(proxyKey, {
              ...deployment,
              timestamp,
              chainId,
            });
          }
        }

        // Only update if this deployment is newer
        if (
          !allDeployments.has(key) ||
          timestamp > allDeployments.get(key).timestamp
        ) {
          allDeployments.set(key, {
            ...deployment,
            timestamp,
            chainId,
            deploymentScript: scriptFolder,
            deployedOnBlock: deployment?.receipt?.blockNumber,
          });
        }
      });
    });
  });

  const allContracts = {};

  allDeployments.forEach((deployment) => {
    const { chainId, contractName } = deployment;

    // Handle renamed contracts: AntToken -> ZLTToken
    let actualContractName = contractName;
    if (contractName === "AntToken") {
      actualContractName = "ZLTToken";
    }

    const artifact = getArtifactOfContract(actualContractName);

    if (artifact) {
      if (!allContracts[chainId]) {
        allContracts[chainId] = {};
      }

      // Use the new contract name (ZLTToken) instead of old name (AntToken)
      allContracts[chainId][actualContractName] = {
        address: deployment.address,
        abi: artifact.abi,
        inheritedFunctions: getInheritedFunctions(artifact),
        deploymentFile: deployment.deploymentFile,
        deploymentScript: deployment.deploymentScript,
        deployedOnBlock:
          deployment?.deployedOnBlock &&
          Number(BigInt(deployment.deployedOnBlock)),
      };
    } else {
      // Log warning if artifact not found (e.g., renamed contract)
      console.warn(
        `Warning: Artifact not found for contract ${contractName} (tried ${actualContractName}). Skipping...`
      );
    }
  });

  return { allContracts, proxyDeployments };
}

function main() {
  const current_path_to_broadcast = join(__dirname, "..", "broadcast");
  const current_path_to_deployments = join(__dirname, "..", "deployments");

  const Deploymentchains = getFiles(current_path_to_deployments);
  const deployments = {};

  // Load existing deployments from deployments directory
  Deploymentchains.forEach((chain) => {
    if (!chain.endsWith(".json")) return;
    chain = chain.slice(0, -5);
    var deploymentObject = JSON.parse(
      readFileSync(`${current_path_to_deployments}/${chain}.json`)
    );
    deployments[chain] = deploymentObject;
  });

  // Process all deployments from all script folders
  const { allContracts, proxyDeployments } = processAllDeployments(
    current_path_to_broadcast
  );

  // Process contracts: prioritize deployments file addresses (proxy addresses)
  // The deployments file contains proxy addresses for UUPS contracts
  const allGeneratedContracts = {};

  Object.entries(allContracts).forEach(([chainId, contracts]) => {
    allGeneratedContracts[chainId] = {};
    const chainDeployments = deployments[chainId] || {};

    // First pass: Process contracts from deployments file (these are proxy addresses)
    // This is the most reliable source for proxy addresses
    Object.entries(chainDeployments).forEach(([proxyAddress, contractName]) => {
      if (contractName === "networkName") return;

      // Handle renamed contracts: AntToken -> ZLTToken
      let actualContractName = contractName;
      if (contractName === "AntToken") {
        actualContractName = "ZLTToken";
      }

      // Find implementation contract by name in broadcast (try both old and new names)
      const implContract =
        contracts[actualContractName] || contracts[contractName];

      if (implContract) {
        // Proxy contract: use proxy address from deployments, keep implementation ABI
        // This ensures we use the proxy address but with the correct ABI
        // Use the new contract name (ZLTToken) instead of old name (AntToken)
        allGeneratedContracts[chainId][actualContractName] = {
          ...implContract,
          address: proxyAddress, // Use proxy address from deployments file
        };
      } else {
        // Try to find by address (might be a non-proxy contract or implementation)
        const foundByAddress = Object.values(contracts).find(
          (c) => c.address.toLowerCase() === proxyAddress.toLowerCase()
        );
        if (foundByAddress) {
          allGeneratedContracts[chainId][actualContractName] = {
            ...foundByAddress,
            address: proxyAddress,
          };
        }
      }
    });

    // Second pass: Add contracts from broadcast not in deployments file
    // These are either non-proxy contracts or new deployments
    Object.entries(contracts).forEach(([contractName, contractData]) => {
      // Skip if already processed from deployments file
      if (allGeneratedContracts[chainId][contractName]) {
        return;
      }

      // Skip ERC1967Proxy itself (we don't need it in the generated contracts)
      if (contractName === "ERC1967Proxy") {
        return;
      }

      // Check if this address is in deployments file with a different name
      // (meaning it's a proxy address we haven't processed yet)
      const deploymentEntry = Object.entries(chainDeployments).find(
        ([addr]) => addr.toLowerCase() === contractData.address.toLowerCase()
      );

      if (deploymentEntry && deploymentEntry[1] !== contractName) {
        // This address is a proxy, but with a different name in deployments
        // Use the name from deployments file
        allGeneratedContracts[chainId][deploymentEntry[1]] = {
          ...contractData,
          address: deploymentEntry[0],
        };
      } else {
        // No proxy found, use as-is (non-proxy contract)
        allGeneratedContracts[chainId][contractName] = contractData;
      }
    });
  });

  const SVELTEKIT_TARGET_DIR = "../sveltekit/src/lib/contracts/";
  // Ensure target directories exist
  if (!existsSync(SVELTEKIT_TARGET_DIR)) {
    mkdirSync(SVELTEKIT_TARGET_DIR, { recursive: true });
  }

  // Generate the deployedContracts content
  const fileContent = Object.entries(allGeneratedContracts).reduce(
    (content, [chainId, chainConfig]) => {
      const cleanedChainConfig = Object.fromEntries(
        Object.entries(chainConfig).map(([contractName, contractData]) => {
          const { deploymentFile, deploymentScript, ...rest } = contractData;
          return [contractName, rest];
        })
      );
      return `${content}${parseInt(chainId).toFixed(0)}:${JSON.stringify(
        cleanedChainConfig,
        null,
        2
      )},`;
    },
    ""
  );

  // Write the files
  const fileTemplate = (importPath) => `
    ${generatedContractComment}
    import type { GenericContractsDeclaration } from "${importPath}";

    const deployedContracts = {${fileContent}} as const;

    export default deployedContracts satisfies GenericContractsDeclaration;
  `;

  // Generate for SvelteKit
  writeFileSync(
    `${SVELTEKIT_TARGET_DIR}deployedContracts.ts`,
    format(fileTemplate("../utils/contractTypes.js"), {
      parser: "typescript",
    })
  );

  console.log(
    `üìù Updated TypeScript contract definition file on ${SVELTEKIT_TARGET_DIR}deployedContracts.ts`
  );
}

try {
  main();
} catch (error) {
  console.error("Error:", error);
  process.exitCode = 1;
}
